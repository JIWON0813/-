<h1>AOP란?</h1>

일반적인 개론은 생략
<br>
AOP란 공통으로 쓰이는 모듈을 따로 만들어서 쓸 수 있도록 만든 스프링 기법
</br>
프로젝트를 만들면서 예외처리와 로그에 대해 각 메소드에 try catch를 각각 붙이면서 사용하려는데 스프링 공부를하면서 AOP라는 개념을 알게됌</br>
바로 예외처리관련 AOP를 만들면서 AOP에 대한 개념을 어느정도 이해했다 유지보수 측면에서 정말 편하고 좋은 기능</br>
기존에는 각 메소드마다 해줘야 했다고 하면 AOP는 모듈을 만들고 빈들을 해당 모듈에 통하도록 AOP모듈에 경로를 지정해주면 됌</br>
기본적으로 Controller -> Service -> Repository 로 흘렀다면 AOP를 적용했을 때 프록시 빈이 생성된다</br>
진짜 Bean이 아닌 가짜(프록시) Bean을 참조하면서 AOP가 실행되고 그 후에 진짜 Bean이 실행됌


<h1>IoC</h1>

<br>
직역하면 "제어의 역전". 메소드나 객체의 호출을 개발자가 아닌 Spring에서 하는 것을 의미.
</br>
제어의 흐름을 내가 아닌 Spring이라고 이해하면 쉬움. 의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드 작성을 할 수 있게 한다.(이론설명. 증명은 나중에)<br>
가독성, 코드 중복, 유지 보수를 편하게 할 수 있게 한다.<br>
Ex)<br>
사람이 직접 할 경우 객체 선언 -> 의존성 객체 생성(클래스 내부) -> 의존성 객체 메소드 호출
<br><br>
Spring 객체 선언 -> 의존성 객체 주입(DI 추후 설명) -> 의존성 객체 메소드 호출
<br><br>
스프링이 모든 의존성 객체를 스프링이 실행될 때 다 만들어주고 만들어진 인스턴스를 주입시켜준다<br>
Bean(추후 설명)들은 싱글턴 패턴의 특징을 가지며 스프링이 만들고 주입시켜주는 방식으로<br>
제어의 흐름을 사용자가 컨트롤 하는 것이 아니라 스프링엥게 맡겨 작업을 처리하게 된다.

<h1>DI</h1>

<br>
의존 관계 주입 기능 객체를 직접 생성하는게 아니라 외부에서 생성한 후 주입 시켜주는 방식
</br>
~~~

<h1>Bean</h1>

<br>
IoC 컨테이너가 관리하는 자바 객체
</br>
IoC는 상단 설명처럼 제어를 내가 아닌 Spring이 하는 제어의 역전을 말하는 것인데 결국 Spring이 객체를 생성하고 관리해주는 자바 객체를 Bean라고 한다.<br>
고로 내가 직접 생성하는 것이 아닌 Spring에서 자바 객체를 얻어서 사용해야한다.<br>

<h1>OOP 5대 원칙 (SOLID)</h1>

<br>
객체 지향 설계 원칙
<br>
<h3>단일 책임 원칙</h3>
요점 클래스에 대해 목적에 맞는 기능을 넣는다. 한 기능에 여러 역할을 두지 마라<br>
<br>
ex)<br>
<h4>함수</h4>
더하기와 출력하기가 있는데 함수를 줄이기 위해서 더하기와 출력을 하나의 함수로 만들 필요는 없다.<br>
<h4>클래스</h4>
고양이 라는 클래스가 있을 때 먹기, 걷기 라는 기능은 고양이라는 클래스에 적합하다.<br>
하지만 고양이의 정보 출력이나 로그 남기기는 고양이 클래스에 있어야할 기능으로는 적합하지 않다.(강의를 들으며 상속을 생각해봤는데 동물에 대한 기능으로도 적합하지 않다.)<br>
고양이의 정보를 리턴하는 함수를 만들고 필요한 곳에서 정보 출력과 로그남기기를 사용하는 것이 올바르다.
<br>
<h3>개방-폐쇄 원칙</h3>
확장에 대해서는 열어두고 수정에 대해서는 닫아놔라<br>
<br>
ex)
<h4>위배되는 코드</h4>
<pre>
class 동물
&nbsp; 동물 타입
&nbsp; 
&nbsp; 생성자(타입)
&nbsp; &nbsp; 동물 타입 = 타입
&nbsp; 
&nbsp; 함수 말하기(동물)
&nbsp; &nbsp; if(동물 == 고양이)
&nbsp; &nbsp; &nbsp; print(야옹)    
&nbsp; &nbsp; else if(동물 == 강아지)
&nbsp; &nbsp; &nbsp; print(멍멍)   
&nbsp; &nbsp; else
&nbsp; &nbsp; &nbsp; 에러 호출
&nbsp; 
cat = 동물(고양이)
dog = 동물(강아지)
&nbsp; 
cat.말하기
dog.말하기
</pre>
만약 클라이언트가 소와 양을 추가해달라하면 동물에 대한 수정이 필요함 확장성은 닫혀있고 수정은 열려있는 원칙에 위배되는 상황
<br>
<h5>적절한 코드</h5>
<pre>
interface 동물
&nbsp; 동물 타입
&nbsp; 
&nbsp; 추상 함수 말하기
&nbsp; 
class 고양이 : 동물
&nbsp; 말하기
&nbsp; &nbsp; print(야옹)
&nbsp; 
class 강아지 : 동물
&nbsp; 말하기
&nbsp; &nbsp; print(멍멍)
&nbsp; 
cat.말하기
dog.말하기
</pre>
<br>
만약 클라이언트가 소와 양을 추가해달라하면 기존 코드는 건드릴 필요 없이 확장만 하면 사용 

<h3>리스코프 치환 원칙</h3>

<h3>인터페이스 분리 원칙</h3>

<h3>의존관계 역전 원칙</h3>

<br>
<h1>JVM</h1>

<br>
자바 가상 머신
</br>
자바와 OS 사이의 중개자 역할<br>
이전에 C로 개발을 했을 때 리눅스와 윈도우에 둘 다 실행이 되도록 조건에 따라 다른 코드를 짠 적이 있는데 자바는 JVM덕분에 그럴 필요가 없다<br>
알아서 OS에 맞게 변환이 되기 때문에 따로 코딩할 필요X<br>
<br>
자바 프로그램 실행 과정<br>
<br>
JVM 메모리 할당 -> 메모리를 여러 영역으로 나눔(메모리 영역들 개념 중요) -> javac가 .java를 .class로 변환<br>
-> Class Loader를 통해 class파일을 JVM으로 로딩 -> 로딩된 클래스 파일들은 Execution engine을 통해 해석 -> 해석된 바이트코드는 Runtime Data Areas에 배치되어 수행 이루어짐<br>
<br>
추후 설명(Execution engine, Class Loader, Runtime Data Area)

<br>
<h1>Servlet, JSP</h1>

<h3>Servlet</h3>
웹 요청에 대해 처리하는 자바 프로그램<br>
Java코드 안에 HTML코드<br>
DB통신, 비즈니스로직 호출, 데이터 작업 등에 유용<br>
Servlet이 수정된 경우 재빌드하고 재배포 작업이 필요함<br>
<h3>JSP</h3>
Java언어를 기반으로 하는 Server Side스크립트 언어(서버 사이드 스크립트 - 서버쪽에서 행해지는 처리)<br>
HTML코드 안에 Jave코드<br>
요청 결과를 나타낼 때 유용<br>
JSP가 수정된 경우 재배포할 필요 없이 WAS가 알아서 처리<br>
<h3>동작과정</h3>
JSP -> 내부적으로 WAS에서 Servlet파일로 변환 -> JSP 태그를 분해하고 추출하여 순수한 HTML웹 페이지로 변환 후 응답

JSP, Servlet -> View부분은 HTML, JSP사용 -> Conrollder(Servlet의 매핑) -> 데이터 관련 작업(DB 접근 등등) *이것이 바로 MVC패턴

